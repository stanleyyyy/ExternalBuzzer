//
// Device: M5Stamp (BUILD_PICO_STAMP == 1) or M5Stack Atom Lite (BUILD_PICO_STAMP == 0)
//

#if BUILD_PICO_STAMP
#include "Arduino.h"
#include <FastLED.h>
#else
#include "M5Atom.h"
#endif

#include <WiFi.h>
#include <wiring_private.h>

#include <SensirionI2CScd4x.h>
#include <Wire.h>

#include <ArduinoJson.h>
#include <map>
#include <functional>

// this needs PathVariableHandlers library
#include <UrlTokenBindings.h>
#include <RichHttpServer.h>
#include <ArduinoOTA.h>

#include "Wireless.h"
#include "definitions.h"
#include "utilities.h"

//
// global object
//

using namespace std::placeholders;
using RichHttpConfig = RichHttp::Generics::Configs::EspressifBuiltin;
using RequestContext = RichHttpConfig::RequestContextType;

class Context {
public:
	float m_temperature;
	float m_humidity;
	uint16_t m_co2;

	SemaphoreHandle_t m_mutex = NULL;
	uint32_t m_watchdogResetTs = 0;
	uint32_t m_periodicResetTs = 0;

	// http server
	SimpleAuthProvider m_authProvider;
	RichHttpServer<RichHttpConfig> m_server;
	SensirionI2CScd4x m_scd4x;

	bool m_ledOn = false;
	uint8_t m_brightness = 0;
	uint32_t m_color = COLOR_RED;

	int32_t m_ledCycle = 0;
	uint32_t m_lastMillis = 0;

#if BUILD_PICO_STAMP
	// Define the array of leds
	CRGB m_leds[NUM_LEDS];
#endif

	Context()
	: m_temperature(0)
	, m_humidity(0)
	, m_co2(0)
	, m_mutex(NULL)
	, m_watchdogResetTs(0)
	, m_periodicResetTs(0)
	, m_server(80, m_authProvider)
	, m_ledOn(true)
	, m_brightness(BRIGHTNESS)
	, m_color(COLOR_RED)
	, m_ledCycle(0)
	, m_lastMillis(0)
	{
	}

} g_ctx;

// create instance of telnet/serial wrapper
TelnetSpy SerialAndTelnet;

//
// Watchdog task
//

uint32_t timeToReset()
{
	return PERIODIC_RESET_TIMEOUT - (millis() - g_ctx.m_periodicResetTs);
}

//
// HTTP handlers
//

void watchdogReset()
{
	if (xSemaphoreTake(g_ctx.m_mutex, (TickType_t)5) == pdTRUE) {
		g_ctx.m_watchdogResetTs = millis();
		xSemaphoreGive(g_ctx.m_mutex);
	}
}

bool getSensorData(float &temperature, float &humidity, uint16_t &co2)
{
	// Read Measurement
	uint16_t error = g_ctx.m_scd4x.readMeasurement(co2, temperature, humidity);
	if (error) {
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("Error trying to execute readMeasurement(): %s\n", errorMessage);
		return false;
	} else if (co2 == 0) {
		LOG_PRINTF("Invalid sample detected, skipping.\n");
		return false;
	} else {
		LOG_PRINTF("CO2: %d ppm, temperature = %f Â°C, humidity = %f %%\n", co2, temperature, humidity);

		// update internal values
		g_ctx.m_co2 = co2;
		g_ctx.m_temperature = temperature;
		g_ctx.m_humidity = humidity;
		return true;
	}
}


void WatchdogTask(void *pvParameters __attribute__((unused)))
{
	while (1) {

		uint32_t diffMs = 0;
		if (xSemaphoreTake(g_ctx.m_mutex, (TickType_t)5) == pdTRUE) {
			diffMs = millis() - g_ctx.m_watchdogResetTs;
			xSemaphoreGive(g_ctx.m_mutex);
		}

		if (diffMs > WATCHDOG_TIMEOUT){
			LOG_PRINTF("Watchddog timeout elapsed, resetting the board!\n");
			delay(2000);
			ESP.restart();
		}

		uint32_t periodicResetDiff = millis() - g_ctx.m_periodicResetTs;

		if (periodicResetDiff > PERIODIC_RESET_TIMEOUT) {
			LOG_PRINTF("Periodic reset!\n");
			delay(2000);
			ESP.restart();
		}

		delay(2000);
	}
}

void ServerTask(void *pvParameters __attribute__((unused)))
{
	g_ctx.m_server
		.buildHandler("/")
		.setDisableAuthOverride()
		.on(HTTP_GET, indexHandler);

	g_ctx.m_server
		.buildHandler("/info")
		.setDisableAuthOverride()
		.on(HTTP_GET, infoHandler);

	g_ctx.m_server
		.buildHandler("/get")
		.setDisableAuthOverride()
		.on(HTTP_GET, getHandler);

	g_ctx.m_server
		.buildHandler("/rssi")
		.setDisableAuthOverride()
		.on(HTTP_GET, rssiHandler);

	g_ctx.m_server
		.buildHandler("/:operation/:value")
		.setDisableAuthOverride()
		.on(HTTP_GET, configureHandler);

	g_ctx.m_server
		.buildHandler("/saveToEeprom")
		.setDisableAuthOverride()
		.on(HTTP_GET, saveToEepromHandler);

	g_ctx.m_server.clearBuilders();
	g_ctx.m_server.begin();

	while (1) {
		// handle one client
		g_ctx.m_server.handleClient();
		delay(100);
	}
}

void telnetConnected()
{
	SERIAL.println("Telnet connection established.");
}

void telnetDisconnected()
{
	SERIAL.println("Telnet connection closed.");
}

void setLedColor(uint32_t color, const bool &forceFullBrightness = false);

//
// setup
//

void setup()
{
	SerialAndTelnet.setWelcomeMsg((char *)"CarbonDioxide server by Embedded Softworks, s.r.o.\n\n");
	SerialAndTelnet.setCallbackOnConnect(telnetConnected);
	SerialAndTelnet.setCallbackOnDisconnect(telnetDisconnected);

	SERIAL.begin(115200);
	SERIAL.flush();
	delay(50);

#if	BUILD_PICO_STAMP
	SERIAL.println("M5Stamp initializing...OK");

	// RBG led
	FastLED.addLeds<SK6812, DATA_PIN, RGB>(g_ctx.m_leds, NUM_LEDS);
	delay(10);
#else
	// Init M5Atom
	M5.begin(false, true, true);
	delay(10);
#endif

	// Initialize I2C
	Wire.begin(SDA, SCL);

	//
	// initialize CO2 sensor
	//

	g_ctx.m_scd4x.begin(Wire);

	// stop potentially previously started measurement
	uint16_t error = g_ctx.m_scd4x.stopPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute stopPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	uint16_t serial0;
	uint16_t serial1;
	uint16_t serial2;
	error = g_ctx.m_scd4x.getSerialNumber(serial0, serial1, serial2);
	if (error) {
		LOG_PRINTF("Error trying to execute getSerialNumber(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	} else {
		LOG_PRINTF("Serial: 0x%2x.%2x.%2x\n", serial0, serial1, serial2);
	}

	// configure sensor altitude
	error = g_ctx.m_scd4x.setSensorAltitude(ALTITUDE);
	if (error) {
		LOG_PRINTF("Error trying to execute setSensorAltitude(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	} else {
		LOG_PRINTF("sensor altitude was successfully set to %d\n", ALTITUDE);
	}

	// Start Measurement
	error = g_ctx.m_scd4x.startPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute startPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	SERIAL.println("Waiting for first measurement... (5 sec)");

	// red LED
	setLedColor(COLOR_RED, true);

#if 0
	// wait until serial is available
	while (!Serial) {};
#endif

	// create semaphore for watchdog
	g_ctx.m_mutex = xSemaphoreCreateMutex();

	watchdogReset();
	g_ctx.m_periodicResetTs = millis();

	xTaskCreatePinnedToCore(
			WatchdogTask,		// pointer to thread function
			"WatchdogTask",		// thread name
			8192,				// This stack size can be checked & adjusted by reading the Stack Highwater
			NULL,				// Parameters for the task
			3,					// Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.
			NULL,				// Task Handle
			ARDUINO_RUNNING_CORE);
}

void setAmbientPressure(uint16_t pressure)
{
	uint16_t error = g_ctx.m_scd4x.setAmbientPressure(AIR_PRESSURE);
	if (error) {
		LOG_PRINTF("Error trying to execute setAmbientPressure(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	} else {
		LOG_PRINTF("sensor ambient pressure was successfully set to %d kPa\n", AIR_PRESSURE);
	}
}

int16_t forceRecalibration(const uint16_t &targetCo2Concentration)
{
	int16_t frcCorrection = 0;

	// stop potentially previously started measurement
	uint16_t error = g_ctx.m_scd4x.stopPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute stopPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	// wait at least 500ms
	delay(500);

	uint16_t frc = 0;
	error = g_ctx.m_scd4x.performForcedRecalibration(targetCo2Concentration, frc);
	if (error) {
		LOG_PRINTF("Error trying to execute performForcedRecalibration(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	} else {
		// calculate FRC correction based on datasheet
		if (frc != 0xFFFF) {
			frcCorrection = (int)frc - 0x8000;
		}
		LOG_PRINTF("forced recalibartion to %u ppm succeeded, FRC correction = %d ppm\n", targetCo2Concentration, frcCorrection);
	}

	// re-start measurements
	error = g_ctx.m_scd4x.startPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute startPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	return frcCorrection;
}

void enableAutomaticSelfCalibration(const bool &calibration)
{
	// stop potentially previously started measurement
	uint16_t error = g_ctx.m_scd4x.stopPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute stopPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	error = g_ctx.m_scd4x.setAutomaticSelfCalibration(calibration);
	if (error) {
		LOG_PRINTF("Error trying to execute setAutomaticSelfCalibration(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	} else {
		LOG_PRINTF("automatic self calibration was successfully configured to '%s'\n", calibration ? "true" : "false");
	}

	// re-start measurements
	error = g_ctx.m_scd4x.startPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute startPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}
}

//
// HTTP handlers
//

void indexHandler(RequestContext& request)
{
	const char body[] =
	"Sensirion SCD41 co2/temperature/humidity server <br>"
	"(c) 2021 Embedded Softworks, s.r.o. <br>"
	"<br>"
	"Click <a href=\"/info\">here</a> to show sensor information<br>"
	"Click <a href=\"/get\">here</a> to retrieve co2, temperature and humidity readings<br>"
	"Click <a href=\"/rssi\">here</a> to get RSSI<br><br>"
	"Click <a href=\"/led/100\">here</a> to set LED brightness to 100<br>"
	"Click <a href=\"/pressure/1020\">here</a> to set ambient pressure to 1020 kPa<br>"
	"<br>"
	"Click <a href=\"/recalibrate/852\">here</a> to recalibrate sensor to 852 ppm<br>"
	"<br>"
	"Click <a href=\"/calibration/on\">here</a> to enable automatic self calibration<br>"
	"Click <a href=\"/calibration/off\">here</a> to disable automatic self calibration<br>"
	"<br>"
	"Click <a href=\"/saveToEeprom\">here</a> to save configuration to EEPROM<br>";

	request.response.sendRaw(200, "text/html", body);
}

void infoHandler(RequestContext& request)
{
	JsonObject tempObj = request.response.json.createNestedObject("temperature");
	tempObj["type"] = "SCD41";

	JsonObject humObj = request.response.json.createNestedObject("humidity");
	humObj["type"] = "SCD41";

	JsonObject co2Obj = request.response.json.createNestedObject("co2");
	co2Obj["type"] = "SCD41";

	// stop potentially previously started measurement
	uint16_t error = g_ctx.m_scd4x.stopPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute stopPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	uint16_t serial0;
	uint16_t serial1;
	uint16_t serial2;

	if (!g_ctx.m_scd4x.getSerialNumber(serial0, serial1, serial2)) {
		char serial[32];
		snprintf(serial, sizeof(serial) - 1, "0x%2x.%2x.%2x", serial0, serial1, serial2);
		LOG_PRINTF("Serial: %s\n", serial);
		co2Obj["serial"] = serial;
	} else {
		co2Obj["serial"] = "unknown";
	}

	uint16_t altitude;
	if (!g_ctx.m_scd4x.getSensorAltitude(altitude)) {
		co2Obj["altitude"] = altitude;
	} else {
		co2Obj["altitude"] = "unknown";
	}

	uint16_t ascEnabled = false;
	if (!g_ctx.m_scd4x.getAutomaticSelfCalibration(ascEnabled)) {
		co2Obj["autoCalibrationEnabled"] = ascEnabled ? "true" : "false";
	} else {
		co2Obj["autoCalibrationEnabled"] = "unknown";
	}

	// re-start measurements
	error = g_ctx.m_scd4x.startPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute startPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	uint32_t currTimeMs = millis();
	request.response.json["currTimeMs"] = currTimeMs;
	request.response.json["currTime"] = msToTimeStr(currTimeMs);
	request.response.json["timeToReset"] = msToTimeStr(timeToReset());
}

void getHandler(RequestContext& request)
{
	// print the received signal strength:
	float temperature = 0;
	float humidity = 0;
	uint16_t co2 = 0;

	if (getSensorData(temperature, humidity, co2)) {
		request.response.json["co2"] = co2;
		request.response.json["temperature"] = temperature;
		request.response.json["humidity"] = humidity;
	} else {
		// if we got an error, return previous reading
		request.response.json["co2"] = g_ctx.m_co2;
		request.response.json["temperature"] = g_ctx.m_temperature;
		request.response.json["humidity"] = g_ctx.m_humidity;
	}

	// add time parameter
	uint32_t currTimeMs = millis();
	request.response.json["currTimeMs"] = currTimeMs;
	request.response.json["currTime"] = msToTimeStr(currTimeMs);
	request.response.json["timeToReset"] = msToTimeStr(timeToReset());
}

void rssiHandler(RequestContext& request)
{
	// print the received signal strength:
	long rssi = WiFi.RSSI();
	LOG_PRINTF("signal strength (RSSI): %d dBm\n", rssi);

	request.response.json["rssi"] = rssi;

	// add time parameter
	uint32_t currTimeMs = millis();
	request.response.json["currTimeMs"] = currTimeMs;
	request.response.json["currTime"] = msToTimeStr(currTimeMs);
	request.response.json["timeToReset"] = msToTimeStr(timeToReset());
}

void configureHandler(RequestContext& request)
{
	const char *opParam = request.pathVariables.get("operation");
	const char *valParam = request.pathVariables.get("value");
	if (!opParam || !valParam) {
		LOG_PRINTF("Please use /<operation>/<value> path!\n");
		request.response.json["error"] = "invalid";
	} else {

		// what configuration operation was requested?
		String opParamStr(opParam);

		if (opParamStr == "led") {
			int value = atoi(valParam);
			LOG_PRINTF("LED value: %d\n", value);
			setLedBrightness(value);
			request.response.json["led"] = value;
		} else if (opParamStr == "pressure") {
			int value = atoi(valParam);
			LOG_PRINTF("Pressure value: %d kPa\n", value);
			setAmbientPressure(value);
			request.response.json["pressure"] = value;
		} else if (opParamStr == "recalibrate") {
			int value = atoi(valParam);
			LOG_PRINTF("Forcing recalibration to: %d kPa\n", value);
			int16_t frcCorrection = forceRecalibration(value);
			request.response.json["recalibrate"] = value;
			request.response.json["frcCorrection"] = frcCorrection;
		} else if (opParamStr == "calibration") {
			String calStr(valParam);
			if (calStr == "on") {
				enableAutomaticSelfCalibration(true);
				LOG_PRINTF("Automatic calibration enabled\n");
			} else {
				enableAutomaticSelfCalibration(false);
				LOG_PRINTF("Automatic calibration disabled\n");
			}
		}
	}

	// add time parameter
	uint32_t currTimeMs = millis();
	request.response.json["currTimeMs"] = currTimeMs;
	request.response.json["currTime"] = msToTimeStr(currTimeMs);
	request.response.json["timeToReset"] = msToTimeStr(timeToReset());
}

void saveToEepromHandler(RequestContext& request)
{
	// stop potentially previously started measurement
	uint16_t error = g_ctx.m_scd4x.stopPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute stopPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	error = g_ctx.m_scd4x.persistSettings();
	if (error) {
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("persistSettings() finished with %s\n", errorMessage);
		request.response.json["status"] = "failed";
		request.response.json["error"] = errorMessage;
	} else {
		LOG_PRINTF("persistSettings() succeeded\n");
		request.response.json["status"] = "succeeded";
	}

	// re-start measurements
	error = g_ctx.m_scd4x.startPeriodicMeasurement();
	if (error) {
		LOG_PRINTF("Error trying to execute startPeriodicMeasurement(): ");
		char errorMessage[256];
		errorToString(error, errorMessage, 256);
		LOG_PRINTF("%s\n", errorMessage);
	}

	// add time parameter
	uint32_t currTimeMs = millis();
	request.response.json["currTimeMs"] = currTimeMs;
	request.response.json["currTime"] = msToTimeStr(currTimeMs);
	request.response.json["timeToReset"] = msToTimeStr(timeToReset());
}

void recalculateLed(const bool &forceFullBrightness = false)
{
	uint8_t brightness = forceFullBrightness ? 0xff : g_ctx.m_brightness;
#if	BUILD_PICO_STAMP
	uint8_t b = ((uint8_t *)&g_ctx.m_color)[0];
	uint8_t r = ((uint8_t *)&g_ctx.m_color)[1];
	uint8_t g = ((uint8_t *)&g_ctx.m_color)[2];

	g_ctx.m_leds[0] = COLOR(r, g, b, g_ctx.m_ledOn ? brightness : 0);
	FastLED.show();
#else
	uint8_t r = ((uint8_t *)&g_ctx.m_color)[2];
	uint8_t g = ((uint8_t *)&g_ctx.m_color)[1];
	uint8_t b = ((uint8_t *)&g_ctx.m_color)[0];

	M5.dis.drawpix(0, COLOR(r, g, b, g_ctx.m_ledOn ? brightness : 0));
#endif
}

void setLedBrightness(uint8_t brightness)
{
	g_ctx.m_brightness = brightness;
	recalculateLed();
}

void setLedColor(uint32_t color, const bool &forceFullBrightness)
{
	g_ctx.m_color = color;
	recalculateLed(forceFullBrightness);
}

void advanceLedBlink()
{
	// tick every 100ms
	if (millis() - g_ctx.m_lastMillis > 100) {
		g_ctx.m_lastMillis = (millis() / 100) * 100;

		if (!g_ctx.m_ledCycle) {
			g_ctx.m_ledOn = true;
		} else {
			g_ctx.m_ledOn = false;
		}
		recalculateLed();
		g_ctx.m_ledCycle++; 

		// blink ever 5 seconds
		if (g_ctx.m_ledCycle > 50) {
			g_ctx.m_ledCycle = 0;
		}
	}
}

void loop()
{
	//
	// We start by connecting to a WiFi network
	//

	if (!wifiReconnect()) {
		LOG_PRINTF("Failed to reconnect, restarting board!\n");
		setLedColor(COLOR_RED, true);
		ESP.restart();
	}

	//
	// arduino ota
	//

	ArduinoOTA
		.onStart([]() {
			String type;
			if (ArduinoOTA.getCommand() == U_FLASH)
				type = "sketch";
			else // U_SPIFFS
				type = "filesystem";

			// NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
			SERIAL.println("Start updating " + type);
		})
		.onEnd([](){
			SERIAL.println("\nEnd");
		})
		.onProgress([](unsigned int progress, unsigned int total) {
			SERIAL.printf("Progress: %u%%\r", (progress / (total / 100)));
			watchdogReset();
		})
		.onError([](ota_error_t error) {
			SERIAL.printf("Error[%u]: ", error);
			if (error == OTA_AUTH_ERROR) SERIAL.println("Auth Failed");
			else if (error == OTA_BEGIN_ERROR) SERIAL.println("Begin Failed");
			else if (error == OTA_CONNECT_ERROR) SERIAL.println("Connect Failed");
			else if (error == OTA_RECEIVE_ERROR) SERIAL.println("Receive Failed");
			else if (error == OTA_END_ERROR) SERIAL.println("End Failed");
		});

	ArduinoOTA.begin();

	// yellow LED
	setLedColor(COLOR_YELLOW, true);

	{
		// read initial sensor values
		float temperature = 0;
		float humidity = 0;
		uint16_t co2 = 0;

		int cnt = 5;

		while (cnt--) {

			LOG_PRINTF("Reading initial sensor data...\n");
			if (getSensorData(temperature, humidity, co2)) {
				LOG_PRINTF("initial data retrieved!\n");
				break;
			}

			watchdogReset();
			delay(1000);
		}
	}

	// green LED - we are ready to process clients
	setLedColor(COLOR_GREEN);

	// process HTTP clients on background thread
	xTaskCreatePinnedToCore(
			ServerTask,			// pointer to thread function
			"ServerTask",		// thread name
			32768,				// This stack size can be checked & adjusted by reading the Stack Highwater
			NULL,				// Parameters for the task
			2,					// Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.
			NULL,				// Task Handle
			ARDUINO_RUNNING_CORE);

	while (1) {

		// handle OTA support
		ArduinoOTA.handle();

		// handle telnet
		SerialAndTelnet.handle();

		// update watchdog time
		watchdogReset();

		// periodic Wifi check
		if (!wifiCheckConnection()) {

			// red color indicates network problem
			setLedColor(COLOR_RED, true);

			if (!wifiReconnect()) {
				LOG_PRINTF("Failed to reconnect, restarting board!\n");
				ESP.restart();
			} else {
				// we have reconnected successfully
				setLedColor(COLOR_GREEN);
			}
		}

		advanceLedBlink();
	}
}
